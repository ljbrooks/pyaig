// Note: The license below is based on the template at:
// http://opensource.org/licenses/BSD-3-Clause
// Copyright (C) 2020 Regents of the University of Texas
//All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:

// o Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.

// o Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the distribution.

// o Neither the name of the copyright holders nor the names of its
//   contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Original Author(s):
// Mertcan Temel         <mert@utexas.edu>

// DO NOT REMOVE:
// This file is generated by Temel's multiplier generator. Download from https://github.com/temelmertcan/multgen.

module c42_USP_RP_8x8_noX(
        input logic [7:0] IN1,
        input logic [7:0] IN2,
        output logic [15:0] result);
    
    
// Creating Partial Products 

    wire logic [7:0] pp0;
    wire logic [7:0] pp1;
    wire logic [7:0] pp2;
    wire logic [7:0] pp3;
    wire logic [7:0] pp4;
    wire logic [7:0] pp5;
    wire logic [7:0] pp6;
    wire logic [7:0] pp7;
    assign pp0 = {8{IN1[0]}} & IN2;
    assign pp1 = {8{IN1[1]}} & IN2;
    assign pp2 = {8{IN1[2]}} & IN2;
    assign pp3 = {8{IN1[3]}} & IN2;
    assign pp4 = {8{IN1[4]}} & IN2;
    assign pp5 = {8{IN1[5]}} & IN2;
    assign pp6 = {8{IN1[6]}} & IN2;
    assign pp7 = {8{IN1[7]}} & IN2;
    
    // The values to be summed in the summation tree, from LSB (left) to MSB:
     // pp0[0] pp0[1] pp0[2] pp0[3] pp0[4] pp0[5] pp0[6] pp0[7]   --     --     --     --     --     --     --   
     //   --   pp1[0] pp1[1] pp1[2] pp1[3] pp1[4] pp1[5] pp1[6] pp1[7]   --     --     --     --     --     --   
     //   --     --   pp2[0] pp2[1] pp2[2] pp2[3] pp2[4] pp2[5] pp2[6] pp2[7]   --     --     --     --     --   
     //   --     --     --   pp3[0] pp3[1] pp3[2] pp3[3] pp3[4] pp3[5] pp3[6] pp3[7]   --     --     --     --   
     //   --     --     --     --   pp4[0] pp4[1] pp4[2] pp4[3] pp4[4] pp4[5] pp4[6] pp4[7]   --     --     --   
     //   --     --     --     --     --   pp5[0] pp5[1] pp5[2] pp5[3] pp5[4] pp5[5] pp5[6] pp5[7]   --     --   
     //   --     --     --     --     --     --   pp6[0] pp6[1] pp6[2] pp6[3] pp6[4] pp6[5] pp6[6] pp6[7]   --   
     //   --     --     --     --     --     --     --   pp7[0] pp7[1] pp7[2] pp7[3] pp7[4] pp7[5] pp7[6] pp7[7] 
    
// Creating Summation Tree 

    
    // 4to2 compressor tree Stage 1
    
    wire cout0;
    wire [10:0] sum0;
    wire [10:0] carry0;
    Four2Two #(11) cmp42_0(
            .in1({pp7[7], pp6[7], pp5[7], pp4[7], pp3[7], pp2[7], pp1[7], pp0[7:4]}),
            .in2({1'b0, pp7[6], pp6[6], pp5[6], pp4[6], pp3[6], pp2[6], pp1[6:3]}),
            .in3({2'b0, pp7[5], pp6[5], pp5[5], pp4[5], pp3[5], pp2[5:2]}),
            .in4({3'b0, pp7[4], pp6[4], pp5[4], pp4[4], pp3[4:1]}),
            .cin(pp4[0]),
            .sum(sum0),
            .carry(carry0),
            .cout(cout0));
    
    wire cout1;
    wire [5:0] sum1;
    wire [5:0] carry1;
    Four2Two #(6) cmp42_1(
            .in1({pp7[3], pp6[3], pp5[3], pp4[3:1]}),
            .in2({1'b0, pp7[2], pp6[2], pp5[2:0]}),
            .in3({2'b0, pp7[1], pp6[1:0], 1'b0}),
            .in4({3'b0, pp7[0], 2'b0}),
            .cin(1'b0),
            .sum(sum1),
            .carry(carry1),
            .cout(cout1));
    
    // 4to2 compressor tree Stage 2
    
    wire cout2;
    wire [13:0] sum2;
    wire [13:0] carry2;
    Four2Two #(14) cmp42_2(
            .in1({carry0[10:0], sum0[0], pp0[3:2]}),
            .in2({cout0, sum0[10:1], 1'b0, pp1[2:1]}),
            .in3({4'b0, carry1[5:0], sum1[0], 1'b0, pp2[1:0]}),
            .in4({4'b0, cout1, sum1[5:1], 2'b0, pp3[0], 1'b0}),
            .cin(1'b0),
            .sum(sum2),
            .carry(carry2),
            .cout(cout2));
    
    assign result[0] = pp0[0];
    logic [15:0] adder_result;
    RP_15 final_adder ({carry2[12], carry2[11], carry2[10], carry2[9], carry2[8], carry2[7], carry2[6], carry2[5], carry2[4], carry2[3], carry2[2], carry2[1], carry2[0], sum2[0], pp0[1] }, {sum2[13], sum2[12], sum2[11], sum2[10], sum2[9], sum2[8], sum2[7], sum2[6], sum2[5], sum2[4], sum2[3], sum2[2], sum2[1], 1'b0, pp1[0] }, adder_result );
    assign result[15:1] = adder_result[14:0];
endmodule



module RP_15 ( 
        input logic [14:0] IN1,
        input logic [14:0] IN2,
        output logic [15:0] OUT);
    
    logic C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15;
    ha m0 (IN1[0], IN2[0], OUT[0], C0);
    fa m1 (IN1[1], IN2[1], C0, OUT[1], C1);
    fa m2 (IN1[2], IN2[2], C1, OUT[2], C2);
    fa m3 (IN1[3], IN2[3], C2, OUT[3], C3);
    fa m4 (IN1[4], IN2[4], C3, OUT[4], C4);
    fa m5 (IN1[5], IN2[5], C4, OUT[5], C5);
    fa m6 (IN1[6], IN2[6], C5, OUT[6], C6);
    fa m7 (IN1[7], IN2[7], C6, OUT[7], C7);
    fa m8 (IN1[8], IN2[8], C7, OUT[8], C8);
    fa m9 (IN1[9], IN2[9], C8, OUT[9], C9);
    fa m10 (IN1[10], IN2[10], C9, OUT[10], C10);
    fa m11 (IN1[11], IN2[11], C10, OUT[11], C11);
    fa m12 (IN1[12], IN2[12], C11, OUT[12], C12);
    fa m13 (IN1[13], IN2[13], C12, OUT[13], C13);
    fa m14 (IN1[14], IN2[14], C13, OUT[14], C14);
    assign OUT[15] = C14;

endmodule

module ha (
        input logic a,
        input logic b,
        output logic s,
        output logic c);
    
    assign s = a ^ b;
    assign c = a & b;
endmodule



module fa (
        input logic x,
        input logic y,
        input logic z,
        output logic s,
        output logic c);
    
    assign s = x ^ y ^ z;
    assign c = (x & y) | (x & z) | (y & z);
endmodule

module Four2Two 
        #(parameter WIDTH=1) (
        input logic [WIDTH-1:0] in1,
        input logic [WIDTH-1:0] in2,
        input logic [WIDTH-1:0] in3,
        input logic [WIDTH-1:0] in4,
        input logic cin,
        output logic [WIDTH-1:0] sum,
        output logic [WIDTH-1:0] carry,
        output logic cout);
    
    wire logic [WIDTH:0] temp1;
    assign temp1 = {((in1 ^ in2)&in3 | in1 & ~(in1^in2)),cin};
    assign sum = ((in1 ^ in2) ^ in3 ^ in4) ^ temp1[WIDTH-1:0];
    assign carry = ((in1 ^ in2) ^ in3 ^ in4) & temp1[WIDTH-1:0] | in4 & ~((in1 ^ in2) ^ in3 ^ in4);
    assign cout = temp1[WIDTH];
endmodule




